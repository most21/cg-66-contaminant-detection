import numpy

from data_utils import read_fasta_files
from data_utils import read_fastq_files
from fasta import FASTA
from fastq import FASTQ

def cost(xc, yc):
# Cost function
    if xc == yc: return 2 # match
    if xc == '-' or yc == '-': return -6 # gap
    return -4

def smithWaterman(x, y, s):
# Smith Waterman from Lecture
    V = numpy.zeros((len(x)+1, len(y)+1), dtype=int)
    for i in range(1, len(x)+1):
        for j in range(1, len(y)+1):
            V[i, j] = max(V[i-1, j-1] + s(x[i-1], y[j-1]),
                          V[i-1, j  ] + s(x[i-1], '-'),
                          V[i  , j-1] + s('-',    y[j-1]),
                          0)
    maxlastrow = V.max(axis = 1)[-1] #changed to get the max of the last row
    lastmax = numpy.where(V == maxlastrow)
    return V, int(V[lastmax])


def readalign_sw(readfh, readid,  humfhs, contamfhs, searchrangehum, searchrangecontam):
    ''' For individual reads passed through a different method, given a search range for
    contaminant and human references (provided in lists),
    find whether the read aligns better to contaminant, human, or ambiguous '''
    # parse reference files
    humFASTA = read_fasta_files(humfhs)
    humgenome = humFASTA.get_data()

    contamFASTA = read_fasta_files(contamfhs)
    contamgenome = contamFASTA.get_data()

    #get the specified read
    fq = read_fastq_files(readfh)
    read = fq.__getitem__(readid)

    contamgenomerange = contamgenome.data[searchrangecontam[0], searchrangecontam[1]]
    humgenomerange = humgenome.data[searchrangehum[0], searchrangehum[1]]

    contamSW, bestcontam = smithWaterman(read, contamgenomerange, cost)
    humSW, besthum = smithWaterman(read, humgenomerange, cost)

    result = None
    if bestcontam > besthum:
        result = 'Contaminant'
    elif bestcontam < besthum:
        result = 'Human'
    elif bestcontam == besthum:
        result = 'Cannot be assigned'

    return readid, result

def sw_overfile(readfh, humfhs, contamfhs):
    ''' Iterate over reads, comparing to references (provided in lists), and return dictionary
    of read ids sorted by whether the reads map to human, contaminant, or ambiguous '''
    # read reference files
    humFASTAs = read_fasta_files(humfhs)
    contamFASTAs = read_fasta_files(contamfhs)
    fq = read_fastq_files(readfh)

    detection = {'Contaminant': [], 'Human': [], 'Cannot be assigned': []}
    #temporary until we decide on standard output format for detection

    for val in fq:
        seqid = val['id']

        contamvals = []
        humvals = []

        for conFA in contamFASTAs:
            contam = conFA.get_data()
            for item in contam:
                contamSW, topcontamval = smithWaterman(val['seq'], item, cost)
                contamvals.append(topcontamval)

        for humFA in humFASTAs:
            chrom = humFA.get_data()
            for item in chrom:
                humSW, tophumval = smithWaterman(val['seq'], item, cost)
                humvals.append(tophumval)

        bestcontam = max(contamvals)
        besthum = max(humvals)

        if bestcontam > besthum:
            detection['Contaminant'].append(seqid)
        elif bestcontam < besthum:
            detection['Human'].append(seqid)
        elif bestcontam == besthum:
            detection['Cannot be assigned'].append(seqid)

    return detection

def removeContamReads(originalfastq, mappingdict, outputfile):
    ''' Add only reads mapping to human genome to a decontaminated output file '''
    fq = read_fastq_files(originalfastq)

    for val in fq:
        if val['id'] in mappingdict['Human']:
            outputfile.append['>', val['id'], '\n', val['seq'], '\n', val['quality'], '\n']
            # need to ask how we want to append to new output files - data utils
